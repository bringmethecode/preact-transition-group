{"version":3,"file":"preact-transition-group-v2.js","sources":["../src/Transition.js","../src/CSSTransition.js","../src/utils/ChildMapping.js","../src/TransitionGroup.js","../src/ReplaceTransition.js"],"sourcesContent":["import { Component, h, cloneElement } from 'preact';\n\nexport const UNMOUNTED = 'unmounted';\nexport const EXITED = 'exited';\nexport const ENTERING = 'entering';\nexport const ENTERED = 'entered';\nexport const EXITING = 'exiting';\n\n/**\n * The Transition component lets you describe a transition from one component\n * state to another _over time_ with a simple declarative API. Most commonly\n * it's used to animate the mounting and unmounting of a component, but can also\n * be used to describe in-place transition states as well.\n *\n * By default the `Transition` component does not alter the behavior of the\n * component it renders, it only tracks \"enter\" and \"exit\" states for the components.\n * It's up to you to give meaning and effect to those states. For example we can\n * add styles to a component when it enters or exits:\n *\n * ```jsx\n * import Transition from 'react-transition-group/Transition';\n *\n * const duration = 300;\n *\n * const defaultStyle = {\n *   transition: `opacity ${duration}ms ease-in-out`,\n *   opacity: 0,\n * }\n *\n * const transitionStyles = {\n *   entering: { opacity: 0 },\n *   entered:  { opacity: 1 },\n * };\n *\n * const Fade = ({ in: inProp }) => (\n *   <Transition in={inProp} timeout={duration}>\n *     {(state) => (\n *       <div style={{\n *         ...defaultStyle,\n *         ...transitionStyles[state]\n *       }}>\n *         I'm a fade Transition!\n *       </div>\n *     )}\n *   </Transition>\n * );\n * ```\n *\n * As noted the `Transition` component doesn't _do_ anything by itself to its child component.\n * What it does do is track transition states over time so you can update the\n * component (such as by adding styles or classes) when it changes states.\n *\n * There are 4 main states a Transition can be in:\n *  - `'entering'`\n *  - `'entered'`\n *  - `'exiting'`\n *  - `'exited'`\n *\n * Transition state is toggled via the `in` prop. When `true` the component begins the\n * \"Enter\" stage. During this stage, the component will shift from its current transition state,\n * to `'entering'` for the duration of the transition and then to the `'entered'` stage once\n * it's complete. Let's take the following example:\n *\n * ```jsx\n * state = { in: false };\n *\n * toggleEnterState = () => {\n *   this.setState({ in: true });\n * }\n *\n * render() {\n *   return (\n *     <div>\n *       <Transition in={this.state.in} timeout={500} />\n *       <button onClick={this.toggleEnterState}>Click to Enter</button>\n *     </div>\n *   );\n * }\n * ```\n *\n * When the button is clicked the component will shift to the `'entering'` state and\n * stay there for 500ms (the value of `timeout`) before it finally switches to `'entered'`.\n *\n * When `in` is `false` the same thing happens except the state moves from `'exiting'` to `'exited'`.\n *\n * ## Timing\n *\n * Timing is often the trickiest part of animation, mistakes can result in slight delays\n * that are hard to pin down. A common example is when you want to add an exit transition,\n * you should set the desired final styles when the state is `'exiting'`. That's when the\n * transition to those styles will start and, if you matched the `timeout` prop with the\n * CSS Transition duration, it will end exactly when the state changes to `'exited'`.\n *\n * > **Note**: For simpler transitions the `Transition` component might be enough, but\n * > take into account that it's platform-agnostic, while the `CSSTransition` component\n * > [forces reflows](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)\n * > in order to make more complex transitions more predictable. For example, even though\n * > classes `example-enter` and `example-enter-active` are applied immediately one after\n * > another, you can still transition from one to the other because of the forced reflow\n * > (read [this issue](https://github.com/reactjs/react-transition-group/issues/159#issuecomment-322761171)\n * > for more info). Take this into account when choosing between `Transition` and\n * > `CSSTransition`.\n */\nclass Transition extends Component {\n\tconstructor(props, context) {\n\t\tsuper(props, context);\n\n\t\tlet parentGroup = context.transitionGroup;\n\t\t// In the context of a TransitionGroup all enters are really appears\n\t\tlet appear =\n\t\t\tparentGroup && !parentGroup.isMounting ? props.enter : props.appear;\n\n\t\tlet initialStatus;\n\n\t\tthis.appearStatus = null;\n\n\t\tif (props.in) {\n\t\t\tif (appear) {\n\t\t\t\tinitialStatus = EXITED;\n\t\t\t\tthis.appearStatus = ENTERING;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinitialStatus = ENTERED;\n\t\t\t}\n\t\t}\n\t\telse if (props.unmountOnExit || props.mountOnEnter) {\n\t\t\tinitialStatus = UNMOUNTED;\n\t\t}\n\t\telse {\n\t\t\tinitialStatus = EXITED;\n\t\t}\n\n\t\tthis.state = { status: initialStatus };\n\n\t\tthis.nextCallback = null;\n\t}\n\n\tgetChildContext() {\n\t\treturn { transitionGroup: null }; // allows for nested Transitions\n\t}\n\n\tstatic getDerivedStateFromProps({ in: nextIn }, prevState) {\n\t\tif (nextIn && prevState.status === UNMOUNTED) {\n\t\t\treturn { status: EXITED };\n\t\t}\n\t\treturn null;\n\t}\n\n\t// getSnapshotBeforeUpdate(prevProps) {\n\t//   let nextStatus = null\n\n\t//   if (prevProps !== this.props) {\n\t//     const { status } = this.state\n\n\t//     if (this.props.in) {\n\t//       if (status !== ENTERING && status !== ENTERED) {\n\t//         nextStatus = ENTERING\n\t//       }\n\t//     } else {\n\t//       if (status === ENTERING || status === ENTERED) {\n\t//         nextStatus = EXITING\n\t//       }\n\t//     }\n\t//   }\n\n\t//   return { nextStatus }\n\t// }\n\n\tcomponentDidMount() {\n\t\tthis.updateStatus(true, this.appearStatus);\n\t}\n\n\tcomponentDidUpdate(prevProps) {\n\t\tlet nextStatus = null;\n\t\tif (prevProps !== this.props) {\n\t\t\tconst { status } = this.state;\n\n\t\t\tif (this.props.in) {\n\t\t\t\tif (status !== ENTERING && status !== ENTERED) {\n\t\t\t\t\tnextStatus = ENTERING;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (status === ENTERING || status === ENTERED) {\n\t\t\t\tnextStatus = EXITING;\n\t\t\t}\n\t\t}\n\t\tthis.updateStatus(false, nextStatus);\n\t}\n\n\tcomponentWillUnmount() {\n\t\tthis.cancelNextCallback();\n\t}\n\n\tgetTimeouts() {\n\t\tconst { timeout } = this.props;\n\t\tlet exit, enter, appear;\n\n\t\texit = enter = appear = timeout;\n\n\t\tif (timeout != null && typeof timeout !== 'number') {\n\t\t\texit = timeout.exit;\n\t\t\tenter = timeout.enter;\n\t\t\tappear = timeout.appear;\n\t\t}\n\t\treturn { exit, enter, appear };\n\t}\n\n\tupdateStatus(mounting = false, nextStatus) {\n\t\tif (nextStatus !== null) {\n\t\t\t// nextStatus will always be ENTERING or EXITING.\n\t\t\tthis.cancelNextCallback();\n\t\t\tconst node = this.base;\n\n\t\t\tif (nextStatus === ENTERING) {\n\t\t\t\tthis.performEnter(node, mounting);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.performExit(node);\n\t\t\t}\n\t\t}\n\t\telse if (this.props.unmountOnExit && this.state.status === EXITED) {\n\t\t\tthis.setState({ status: UNMOUNTED });\n\t\t}\n\t}\n\n\tperformEnter(node, mounting) {\n\t\tconst { enter } = this.props;\n\t\tconst appearing = this.context.transitionGroup\n\t\t\t? this.context.transitionGroup.isMounting\n\t\t\t: mounting;\n\n\t\tconst timeouts = this.getTimeouts();\n\n\t\t// no enter animation skip right to ENTERED\n\t\t// if we are mounting and running this it means appear _must_ be set\n\t\tif (!mounting && !enter) {\n\t\t\tthis.safeSetState({ status: ENTERED }, () => {\n\t\t\t\tthis.props.onEntered(node);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\tthis.props.onEnter(node, appearing);\n\n\t\tthis.safeSetState({ status: ENTERING }, () => {\n\t\t\tthis.props.onEntering(node, appearing);\n\n\t\t\t// FIXME: appear timeout?\n\t\t\tthis.onTransitionEnd(node, timeouts.enter, () => {\n\t\t\t\tthis.safeSetState({ status: ENTERED }, () => {\n\t\t\t\t\tthis.props.onEntered(node, appearing);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tperformExit(node) {\n\t\tconst { exit } = this.props;\n\t\tconst timeouts = this.getTimeouts();\n\n\t\t// no exit animation skip right to EXITED\n\t\tif (!exit) {\n\t\t\tthis.safeSetState({ status: EXITED }, () => {\n\t\t\t\tthis.props.onExited(node);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.props.onExit(node);\n\n\t\tthis.safeSetState({ status: EXITING }, () => {\n\t\t\tthis.props.onExiting(node);\n\n\t\t\tthis.onTransitionEnd(node, timeouts.exit, () => {\n\t\t\t\tthis.safeSetState({ status: EXITED }, () => {\n\t\t\t\t\tthis.props.onExited(node);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tcancelNextCallback() {\n\t\tif (this.nextCallback !== null) {\n\t\t\tthis.nextCallback.cancel();\n\t\t\tthis.nextCallback = null;\n\t\t}\n\t}\n\n\tsafeSetState(nextState, callback) {\n\t\t// This shouldn't be necessary, but there are weird race conditions with\n\t\t// setState callbacks and unmounting in testing, so always make sure that\n\t\t// we can cancel any pending setState callbacks after we unmount.\n\t\tcallback = this.setNextCallback(callback);\n\t\tthis.setState(nextState, callback);\n\t}\n\n\tsetNextCallback(callback) {\n\t\tlet active = true;\n\n\t\tthis.nextCallback = event => {\n\t\t\tif (active) {\n\t\t\t\tactive = false;\n\t\t\t\tthis.nextCallback = null;\n\n\t\t\t\tcallback(event);\n\t\t\t}\n\t\t};\n\n\t\tthis.nextCallback.cancel = () => {\n\t\t\tactive = false;\n\t\t};\n\n\t\treturn this.nextCallback;\n\t}\n\n\tonTransitionEnd(node, timeout, handler) {\n\t\tthis.setNextCallback(handler);\n\n\t\tif (node) {\n\t\t\tif (this.props.addEndListener) {\n\t\t\t\tthis.props.addEndListener(node, this.nextCallback);\n\t\t\t}\n\t\t\tif (timeout != null) {\n\t\t\t\tsetTimeout(this.nextCallback, timeout);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsetTimeout(this.nextCallback, 0);\n\t\t}\n\t}\n\n\trender() {\n\t\tconst status = this.state.status;\n\t\tif (status === UNMOUNTED) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst { children, ...childProps } = this.props;\n\n\t\t// TODO: Use destructuring to filter props\n\t\t// filter props for Transtition\n\t\tdelete childProps.in;\n\t\tdelete childProps.mountOnEnter;\n\t\tdelete childProps.unmountOnExit;\n\t\tdelete childProps.appear;\n\t\tdelete childProps.enter;\n\t\tdelete childProps.exit;\n\t\tdelete childProps.timeout;\n\t\tdelete childProps.addEndListener;\n\t\tdelete childProps.onEnter;\n\t\tdelete childProps.onEntering;\n\t\tdelete childProps.onEntered;\n\t\tdelete childProps.onExit;\n\t\tdelete childProps.onExiting;\n\t\tdelete childProps.onExited;\n\n\t\tif (typeof children === 'function') {\n\t\t\treturn children(status, childProps);\n\t\t}\n\n\t\tconst child = children[0];\n\t\treturn cloneElement(child, childProps);\n\t}\n}\n\n// Name the function so it is clearer in the documentation\nfunction noop() {}\n\nTransition.defaultProps = {\n\tin: false,\n\tmountOnEnter: false,\n\tunmountOnExit: false,\n\tappear: false,\n\tenter: true,\n\texit: true,\n\n\tonEnter: noop,\n\tonEntering: noop,\n\tonEntered: noop,\n\n\tonExit: noop,\n\tonExiting: noop,\n\tonExited: noop\n};\n\nTransition.UNMOUNTED = 0;\nTransition.EXITED = 1;\nTransition.ENTERING = 2;\nTransition.ENTERED = 3;\nTransition.EXITING = 4;\n\nexport default Transition;\n","// TODO: Consider removing dependency on dom-helpers\nimport addOneClass from 'dom-helpers/class/addClass';\nimport removeOneClass from 'dom-helpers/class/removeClass';\n\nimport { Component, h } from 'preact';\n\nimport Transition from './Transition';\n\nconst addClass = (node, classes) =>\n\tnode && node.setAttribute && classes && classes.split(' ').forEach(c => addOneClass(node, c));\nconst removeClass = (node, classes) =>\n\tnode && node.setAttribute && classes && classes.split(' ').forEach(c => removeOneClass(node, c));\n\n/**\n * A `Transition` component using CSS transitions and animations.\n * It's inspired by the excellent [ng-animate](http://www.nganimate.org/) library.\n *\n * `CSSTransition` applies a pair of class names during the `appear`, `enter`,\n * and `exit` stages of the transition. The first class is applied and then a\n * second \"active\" class in order to activate the css animation. After the animation,\n * matching `done` class names are applied to persist the animation state.\n *\n * When the `in` prop is toggled to `true` the Component will get\n * the `example-enter` CSS class and the `example-enter-active` CSS class\n * added in the next tick. This is a convention based on the `classNames` prop.\n */\nclass CSSTransition extends Component {\n\tconstructor(props, context) {\n\t\tsuper(props, context);\n\n\t\t// TODO: Consider using property initializer syntax if buble supports it\n\t\tthis.onEnter = this.onEnter.bind(this);\n\t\tthis.onEntering = this.onEntering.bind(this);\n\t\tthis.onEntered = this.onEntered.bind(this);\n\t\tthis.onExit = this.onExit.bind(this);\n\t\tthis.onExiting = this.onExiting.bind(this);\n\t\tthis.onExited = this.onExited.bind(this);\n\t\tthis.getClassNames = this.getClassNames.bind(this);\n\t}\n\n\tonEnter(node, appearing) {\n\t\tconst { className } = this.getClassNames(appearing ? 'appear' : 'enter');\n\n\t\tthis.removeClasses(node, 'exit');\n\t\taddClass(node, className);\n\n\t\tif (this.props.onEnter) {\n\t\t\tthis.props.onEnter(node);\n\t\t}\n\t}\n\n\tonEntering(node, appearing) {\n\t\tconst { activeClassName } = this.getClassNames(\n\t\t\tappearing ? 'appear' : 'enter'\n\t\t);\n\n\t\tthis.reflowAndAddClass(node, activeClassName);\n\n\t\tif (this.props.onEntering) {\n\t\t\tthis.props.onEntering(node);\n\t\t}\n\t}\n\n\tonEntered(node, appearing) {\n\t\tconst { doneClassName } = this.getClassNames('enter');\n\n\t\tthis.removeClasses(node, appearing ? 'appear' : 'enter');\n\t\taddClass(node, doneClassName);\n\n\t\tif (this.props.onEntered) {\n\t\t\tthis.props.onEntered(node);\n\t\t}\n\t}\n\n\tonExit(node) {\n\t\tconst { className } = this.getClassNames('exit');\n\n\t\tthis.removeClasses(node, 'appear');\n\t\tthis.removeClasses(node, 'enter');\n\t\taddClass(node, className);\n\n\t\tif (this.props.onExit) {\n\t\t\tthis.props.onExit(node);\n\t\t}\n\t}\n\n\tonExiting(node) {\n\t\tconst { activeClassName } = this.getClassNames('exit');\n\n\t\tthis.reflowAndAddClass(node, activeClassName);\n\n\t\tif (this.props.onExiting) {\n\t\t\tthis.props.onExiting(node);\n\t\t}\n\t}\n\n\tonExited(node) {\n\t\tconst { doneClassName } = this.getClassNames('exit');\n\n\t\tthis.removeClasses(node, 'exit');\n\t\taddClass(node, doneClassName);\n\n\t\tif (this.props.onExited) {\n\t\t\tthis.props.onExited(node);\n\t\t}\n\t}\n\n\tgetClassNames(type) {\n\t\tconst { classNames } = this.props;\n\n\t\tlet className =\n\t\t\ttypeof classNames !== 'string'\n\t\t\t\t? classNames[type]\n\t\t\t\t: classNames + '-' + type;\n\n\t\tlet activeClassName =\n\t\t\ttypeof classNames !== 'string'\n\t\t\t\t? classNames[type + 'Active']\n\t\t\t\t: className + '-active';\n\n\t\tlet doneClassName =\n\t\t\ttypeof classNames !== 'string'\n\t\t\t\t? classNames[type + 'Done']\n\t\t\t\t: className + '-done';\n\n\t\treturn {\n\t\t\tclassName,\n\t\t\tactiveClassName,\n\t\t\tdoneClassName\n\t\t};\n\t}\n\n\tremoveClasses(node, type) {\n\t\tconst { className, activeClassName, doneClassName } = this.getClassNames(\n\t\t\ttype\n\t\t);\n\t\tclassName && removeClass(node, className);\n\t\tactiveClassName && removeClass(node, activeClassName);\n\t\tdoneClassName && removeClass(node, doneClassName);\n\t}\n\n\treflowAndAddClass(node, className) {\n\t\t// This is for to force a repaint,\n\t\t// which is necessary in order to transition styles when adding a class name.\n\t\tif (className) {\n\t\t\t/* eslint-disable no-unused-expressions */\n\t\t\tnode && node.scrollTop;\n\t\t\t/* eslint-enable no-unused-expressions */\n\t\t\taddClass(node, className);\n\t\t}\n\t}\n\n\trender() {\n\t\tconst props = { ...this.props };\n\n\t\tdelete props.classNames;\n\n\t\treturn (\n\t\t\t<Transition\n\t\t\t\t{...props}\n\t\t\t\tonEnter={this.onEnter}\n\t\t\t\tonEntered={this.onEntered}\n\t\t\t\tonEntering={this.onEntering}\n\t\t\t\tonExit={this.onExit}\n\t\t\t\tonExiting={this.onExiting}\n\t\t\t\tonExited={this.onExited}\n\t\t\t/>\n\t\t);\n\t}\n}\n\nexport default CSSTransition;\n","import { h, cloneElement } from 'preact';\n\n// This is necessary to filter out invalid children from child mappings\nconst VNode = h('a', null).constructor;\nconst isValidElement = child => child && (child instanceof VNode);\n\n/**\n * Given `this.props.children`, return an object mapping key to child.\n *\n * @param {Array<import('preact').VNode>} children `this.props.children`\n * @param {(child: import('preact').VNode) => any} [mapFn]\n * @return {object} Mapping of key to child\n */\nexport function getChildMapping(children, mapFn) {\n\tlet mapper = child => (mapFn && isValidElement(child) ? mapFn(child) : child);\n\n\tlet result = Object.create(null);\n\tif (children)\n\t\tchildren.forEach(child => {\n\t\t\tif (child) {\n\t\t\t\t// run the map function here instead so that the key is the computed one\n\t\t\t\tresult[child.key] = mapper(child);\n\t\t\t}\n\t\t});\n\treturn result;\n}\n\n/**\n * When you're adding or removing children some may be added or removed in the\n * same render pass. We want to show *both* since we want to simultaneously\n * animate elements in and out. This function takes a previous set of keys\n * and a new set of keys and merges them with its best guess of the correct\n * ordering. In the future we may expose some of the utilities in\n * ReactMultiChild to make this easy, but for now React itself does not\n * directly have this concept of the union of prevChildren and nextChildren\n * so we implement it here.\n *\n * @param {object} prev prev children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @param {object} next next children as returned from\n * `ReactTransitionChildMapping.getChildMapping()`.\n * @return {object} a key set that contains all keys in `prev` and all keys\n * in `next` in a reasonable order.\n */\nexport function mergeChildMappings(prev, next) {\n\tprev = prev || {};\n\tnext = next || {};\n\n\tfunction getValueForKey(key) {\n\t\treturn key in next ? next[key] : prev[key];\n\t}\n\n\t// For each key of `next`, the list of keys to insert before that key in\n\t// the combined list\n\tlet nextKeysPending = Object.create(null);\n\n\tlet pendingKeys = [];\n\tfor (let prevKey in prev) {\n\t\tif (prevKey in next) {\n\t\t\tif (pendingKeys.length) {\n\t\t\t\tnextKeysPending[prevKey] = pendingKeys;\n\t\t\t\tpendingKeys = [];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tpendingKeys.push(prevKey);\n\t\t}\n\t}\n\n\tlet i;\n\tlet childMapping = {};\n\tfor (let nextKey in next) {\n\t\tif (nextKeysPending[nextKey]) {\n\t\t\tfor (i = 0; i < nextKeysPending[nextKey].length; i++) {\n\t\t\t\tlet pendingNextKey = nextKeysPending[nextKey][i];\n\t\t\t\tchildMapping[nextKeysPending[nextKey][i]] = getValueForKey(\n\t\t\t\t\tpendingNextKey\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchildMapping[nextKey] = getValueForKey(nextKey);\n\t}\n\n\t// Finally, add the keys which didn't appear before any key in `next`\n\tfor (i = 0; i < pendingKeys.length; i++) {\n\t\tchildMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);\n\t}\n\n\treturn childMapping;\n}\n\nfunction getProp(child, prop, props) {\n\treturn props[prop] != null ? props[prop] : child.attributes && child.attributes[prop];\n}\n\nexport function getInitialChildMapping(props, onExited) {\n\treturn getChildMapping(props.children, child =>\n\t\tcloneElement(child, {\n\t\t\tonExited: onExited.bind(null, child),\n\t\t\tin: true,\n\t\t\tappear: getProp(child, 'appear', props),\n\t\t\tenter: getProp(child, 'enter', props),\n\t\t\texit: getProp(child, 'exit', props)\n\t\t})\n\t);\n}\n\nexport function getNextChildMapping(nextProps, prevChildMapping, onExited) {\n\tlet nextChildMapping = getChildMapping(nextProps.children);\n\tlet children = mergeChildMappings(prevChildMapping, nextChildMapping);\n\n\tObject.keys(children).forEach(key => {\n\t\tlet child = children[key];\n\n\t\tif (!isValidElement(child)) return;\n\n\t\tconst hasPrev = key in prevChildMapping;\n\t\tconst hasNext = key in nextChildMapping;\n\n\t\tconst prevChild = prevChildMapping[key];\n\t\tconst isLeaving = isValidElement(prevChild) && !prevChild.attributes.in;\n\n\t\t// item is new (entering)\n\t\tif (hasNext && (!hasPrev || isLeaving)) {\n\t\t\t// console.log('entering', key)\n\t\t\tchildren[key] = cloneElement(child, {\n\t\t\t\tonExited: onExited.bind(null, child),\n\t\t\t\tin: true,\n\t\t\t\texit: getProp(child, 'exit', nextProps),\n\t\t\t\tenter: getProp(child, 'enter', nextProps)\n\t\t\t});\n\t\t}\n\t\telse if (!hasNext && hasPrev && !isLeaving) {\n\t\t\t// item is old (exiting)\n\t\t\t// console.log('leaving', key)\n\t\t\tchildren[key] = cloneElement(child, { in: false });\n\t\t}\n\t\telse if (hasNext && hasPrev && isValidElement(prevChild)) {\n\t\t\t// item hasn't changed transition states\n\t\t\t// copy over the last transition props;\n\t\t\t// console.log('unchanged', key)\n\t\t\tchildren[key] = cloneElement(child, {\n\t\t\t\tonExited: onExited.bind(null, child),\n\t\t\t\tin: prevChild.attributes.in,\n\t\t\t\texit: getProp(child, 'exit', nextProps),\n\t\t\t\tenter: getProp(child, 'enter', nextProps)\n\t\t\t});\n\t\t}\n\t});\n\n\treturn children;\n}\n","import { Component, h } from 'preact';\n\nimport {\n\tgetChildMapping,\n\tgetInitialChildMapping,\n\tgetNextChildMapping\n} from './utils/ChildMapping';\n\nconst values = Object.values || (obj => Object.keys(obj).map(k => obj[k]));\n\nconst defaultProps = {\n\tcomponent: 'div',\n\tchildFactory: child => child\n};\n\n/**\n * The `<TransitionGroup>` component manages a set of transition components\n * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition\n * components, `<TransitionGroup>` is a state machine for managing the mounting\n * and unmounting of components over time.\n *\n * Consider the example below. As items are removed or added to the TodoList the\n * `in` prop is toggled automatically by the `<TransitionGroup>`.\n *\n * Note that `<TransitionGroup>`  does not define any animation behavior!\n * Exactly _how_ a list item animates is up to the individual transition\n * component. This means you can mix and match animations across different list\n * items.\n */\nclass TransitionGroup extends Component {\n\tconstructor(props, context) {\n\t\tsuper(props, context);\n\n\t\tconst handleExited = this.handleExited.bind(this);\n\n\t\t// Initial children should all be entering, dependent on appear\n\t\tthis.state = {\n\t\t\thandleExited,\n\t\t\tfirstRender: true\n\t\t};\n\t}\n\n\tgetChildContext() {\n\t\treturn {\n\t\t\ttransitionGroup: { isMounting: !this.appeared }\n\t\t};\n\t}\n\n\tcomponentDidMount() {\n\t\tthis.appeared = true;\n\t}\n\n\tstatic getDerivedStateFromProps(\n\t\tnextProps,\n\t\t{ children: prevChildMapping, handleExited, firstRender }\n\t) {\n\t\treturn {\n\t\t\tchildren: firstRender\n\t\t\t\t? getInitialChildMapping(nextProps, handleExited)\n\t\t\t\t: getNextChildMapping(nextProps, prevChildMapping, handleExited),\n\t\t\tfirstRender: false\n\t\t};\n\t}\n\n\thandleExited(child, node) {\n\t\tlet currentChildMapping = getChildMapping(this.props.children);\n\n\t\tif (child.key in currentChildMapping) return;\n\n\t\tif (child.attributes.onExited) {\n\t\t\tchild.attributes.onExited(node);\n\t\t}\n\n\t\tthis.setState(state => {\n\t\t\tlet children = { ...state.children };\n\n\t\t\tdelete children[child.key];\n\t\t\treturn { children };\n\t\t});\n\t}\n\n\trender() {\n\t\tconst { component: Component, childFactory, ...props } = this.props;\n\t\tconst children = values(this.state.children).map(childFactory);\n\n\t\tdelete props.appear;\n\t\tdelete props.enter;\n\t\tdelete props.exit;\n\n\t\tif (Component === null) {\n\t\t\treturn children;\n\t\t}\n\t\treturn <Component {...props}>{children}</Component>;\n\t}\n}\n\nTransitionGroup.defaultProps = defaultProps;\n\nexport default TransitionGroup;\n","import { Component, h, cloneElement } from 'preact';\nimport TransitionGroup from './TransitionGroup';\n\n/**\n * The `<ReplaceTransition>` component is a specialized `Transition` component\n * that animates between two children.\n *\n * ```jsx\n * <ReplaceTransition in>\n *   <Fade><div>I appear first</div></Fade>\n *   <Fade><div>I replace the above</div></Fade>\n * </ReplaceTransition>\n * ```\n */\nclass ReplaceTransition extends Component {\n\tconstructor(props, context) {\n\t\tsuper(props, context);\n\n\t\tthis.handleEnter = (...args) => this.handleLifecycle('onEnter', 0, args);\n\t\tthis.handleEntering = (...args) => this.handleLifecycle('onEntering', 0, args);\n\t\tthis.handleEntered = (...args) => this.handleLifecycle('onEntered', 0, args);\n\n\t\tthis.handleExit = (...args) => this.handleLifecycle('onExit', 1, args);\n\t\tthis.handleExiting = (...args) => this.handleLifecycle('onExiting', 1, args);\n\t\tthis.handleExited = (...args) => this.handleLifecycle('onExited', 1, args);\n\t}\n\n\thandleLifecycle(handler, idx, originalArgs) {\n\t\tconst { children } = this.props;\n\t\tconst child = children[idx];\n\n\t\tif (child.props[handler]) child.props[handler](...originalArgs);\n\t\tif (this.props[handler]) this.props[handler](this.base);\n\t}\n\n\trender() {\n\t\tconst { children, in: inProp, ...props } = this.props;\n\t\tconst [first, second] = children;\n\n\t\t// TODO: Use destructuring to remove these props\n\t\tdelete props.onEnter;\n\t\tdelete props.onEntering;\n\t\tdelete props.onEntered;\n\t\tdelete props.onExit;\n\t\tdelete props.onExiting;\n\t\tdelete props.onExited;\n\n\t\treturn (\n\t\t\t<TransitionGroup {...props}>\n\t\t\t\t{inProp\n\t\t\t\t\t? cloneElement(first, {\n\t\t\t\t\t\tkey: 'first',\n\t\t\t\t\t\tonEnter: this.handleEnter,\n\t\t\t\t\t\tonEntering: this.handleEntering,\n\t\t\t\t\t\tonEntered: this.handleEntered\n\t\t\t\t\t  })\n\t\t\t\t\t: cloneElement(second, {\n\t\t\t\t\t\tkey: 'second',\n\t\t\t\t\t\tonEnter: this.handleExit,\n\t\t\t\t\t\tonEntering: this.handleExiting,\n\t\t\t\t\t\tonEntered: this.handleExited\n\t\t\t\t\t  })}\n\t\t\t</TransitionGroup>\n\t\t);\n\t}\n}\n\nexport default ReplaceTransition;\n"],"names":["UNMOUNTED","EXITED","ENTERING","ENTERED","Transition","constructor","props","context","initialStatus","parentGroup","transitionGroup","appear","isMounting","enter","appearStatus","in","unmountOnExit","mountOnEnter","state","status","nextCallback","getChildContext","getDerivedStateFromProps","ref","prevState","componentDidMount","updateStatus","this","componentDidUpdate","prevProps","nextStatus","componentWillUnmount","cancelNextCallback","getTimeouts","exit","timeout","mounting","node","base","performEnter","performExit","setState","appearing","timeouts","onEnter","safeSetState","onEntering","onTransitionEnd","onEntered","onExit","onExiting","onExited","cancel","nextState","callback","setNextCallback","active","event","handler","addEndListener","setTimeout","render","childProps","children","cloneElement","Component","noop","defaultProps","EXITING","const","addClass","classes","setAttribute","split","forEach","c","addOneClass","removeClass","removeOneClass","CSSTransition","bind","getClassNames","removeClasses","className","reflowAndAddClass","doneClassName","type","classNames","activeClassName","Object","h","VNode","isValidElement","child","getChildMapping","mapFn","result","create","key","mapper","getProp","prop","attributes","getNextChildMapping","nextProps","prevChildMapping","nextChildMapping","prev","next","getValueForKey","i","nextKeysPending","pendingKeys","let","prevKey","length","push","childMapping","nextKey","mergeChildMappings","keys","hasPrev","hasNext","prevChild","isLeaving","values","obj","map","k","TransitionGroup","handleExited","firstRender","appeared","currentChildMapping","childFactory","component","ReplaceTransition","handleEnter","handleLifecycle","args","handleEntering","handleEntered","handleExit","handleExiting","idx","originalArgs","ref$1","inProp","first","second"],"mappings":"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"}